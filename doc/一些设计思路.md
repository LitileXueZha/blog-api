# 点击量统计

更细的可以划分到 PV、UV 等值，这里只简单的统计点击量。首先要明确统计的几个点：

1. 用户不同 +1
2. 日期不同 +1

还有面临的几个问题：

**刷新页面时，统计 +1 怎么办？**

在客户端生成一个 sessionId，以此来判断是同一用户，当天通过此 sessionId 发送的请求。

# 等一下，还是先直接统计次数好了！

建议另起一个表 `stats` 来统计，而不是在原有基础上增加字段

sql +1 语句：

```sql
UPDATE a
   SET num=num+1
 WHERE id=12
```

# 全文检索

最简单的 `like '%text%'` 无索引的功能，查询效率较慢。

[官方文档](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html)提供了 `FULLTEXT` 索引，用来检索多个 column，但只支持字符串类型。也有内置的分词器 `ngram` 可支持中文。

参考：[MySQL 全文检索方案 - FULLTEXT 索引](https://www.sunzhongwei.com/mysql-full-text-retrieval-scheme-fulltext-indexing)


# token 机制

**由服务端统一生成带用户标识的 jwt**，那就需要 `user` 表来维护。

## API 鉴权

调用 `/oauth` 接口，获取 jwt。可能会有三种场景：

+ 新用户。创建用户 ID，插入用户表以维护，生成 jwt 带此用户标识，返回给前端存储
+ 老用户（在 header 中带上了 jwt）。直接更新此 jwt 的失效时间
+ 管理用户 `/user/login` 登录。为保证安全性，不会刷新 jwt，到了失效时间就要登录

## 规则定义

1. 使用 sha256 的 `hmac` 算法，内部指定盐值
2. 失效时间 3 天
3. 携带用户 id

范例：

```js
// 第一段
{
  "typ": "JWT",
  "alg": "HS256"
}
// 第二段
{
  "exp": 1576036278, // 只精确到秒而不是 ms
  "uid": "b2gaD" // 用户 id
}
// 简写成 1576036278:b2gaD。更短，自定义的可以不用考虑规范
```

## 可能存在的风险

虽说没什么价值，人家对你这个也不感兴趣，可以先思考下😂

### token 被盗用

前端存储的 token 内容被盗，攻击者可以篡改其他人的数据。感觉这个没法儿解决，就像 cookie 被盗了，伪装成其它用户。考虑前端简单地校验下用户 id（算了）

### token 内容修改为其它用户

前提是攻击者已经知道了 token 的生成算法。直接 GG！
